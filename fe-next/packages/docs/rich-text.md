难点一：冲突解决 (CRDT 的数学魔法)
场景： 用户 A 在第 5 个字插入了 "Hello"，用户 B 几乎同时删除了第 3-8 个字。

问题： 如果只是简单的坐标计算，文档会瞬间乱套（Index 错位）。

现状： Y.js 已经完美解决了这个。 这是一个数学算法（CRDT），它保证只要 A 和 B 的操作最终都传到了对方那里，文档内容就绝对一致。

你的工作量：几乎为 0（Y.js 帮你做了）。

难点二：持久化策略 (何时存数据库？)
场景： 两个用户正在疯狂打字。一秒钟可能产生 20 个操作 (Update)。

问题：

你不能每敲一个字就写一次 Postgres (Neon)。数据库会爆炸，流量费会爆炸。

如果你只存在 PartyKit 的内存里，PartyKit 重启（或部署新版本）时，数据就丢了。

难点： 如何设计一个**“防抖 (Debounce) + 定期快照”**的机制，既保证数据不丢，又不搞死数据库。

难点三：离线与重连 (Offline-first)
场景： 用户坐地铁，网断了，但他还在继续写。一分钟后网通了。

问题： 他本地有了很多“离线修改”，服务器上可能别人也有了“新修改”。如何把这两坨修改平滑地合并，而不是简单地“覆盖”？

现状： Y.js 也能处理这个，但你需要配置好 Provider 的连接逻辑。

难点四：复杂的富文本结构同步
场景： 这正是你项目特有的。AI 插入了一个“九宫格图片组件”（自定义 Node），同时用户正在那个位置打字。

问题： 结构化数据（JSON）和文本流的混合冲突。如果处理不好，可能会出现“图片把字吃掉了”或者“图片显示了一半”的 Bug。